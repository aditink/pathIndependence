'use strict';var time={};import{AssertionError,AttributeError,BaseException,DeprecationWarning,Exception,IndexError,IterableError,KeyError,NotImplementedError,RuntimeWarning,StopIteration,UserWarning,ValueError,Warning,__JsIterator__,__PyIterator__,__Terminal__,__add__,__and__,__call__,__class__,__envir__,__eq__,__floordiv__,__ge__,__get__,__getcm__,__getitem__,__getslice__,__getsm__,__gt__,__i__,__iadd__,__iand__,__idiv__,__ijsmod__,__ilshift__,__imatmul__,__imod__,__imul__,__in__,__init__,__ior__,
__ipow__,__irshift__,__isub__,__ixor__,__jsUsePyNext__,__jsmod__,__k__,__kwargtrans__,__le__,__lshift__,__lt__,__matmul__,__mergefields__,__mergekwargtrans__,__mod__,__mul__,__ne__,__neg__,__nest__,__or__,__pow__,__pragma__,__proxy__,__pyUseJsNext__,__rshift__,__setitem__,__setproperty__,__setslice__,__sort__,__specialattrib__,__sub__,__super__,__t__,__terminal__,__truediv__,__withblock__,__xor__,abs,all,any,assert,bool,bytearray,bytes,callable,chr,copy,deepcopy,delattr,dict,dir,divmod,enumerate,
filter,float,getattr,hasattr,input,int,isinstance,issubclass,len,list,map,max,min,object,ord,pow,print,property,py_TypeError,py_iter,py_metatype,py_next,py_reversed,py_typeof,range,repr,round,set,setattr,sorted,str,sum,tuple,zip}from"./org.transcrypt.__runtime__.js";import*as __module_time__ from"./time.js";__nest__(time,"",__module_time__);var __name__="__main__";export var _default_no_edge=-1;export var BaseOnlineChecker=__class__("BaseOnlineChecker",[object],{__module__:__name__,_invalid_node:-1,
_debug:false,get extend(){return __get__(this,function(self,list1,list2){for(var elem of list2)list1.append(elem);return list1})},get getForwardEdges(){return __get__(this,function(self,source){return function(){var __accu0__=[];for(var i=0;i<len(self.graph);i++)if(self.graph[source][i]!=self._no_edge)__accu0__.append(i);return __accu0__}()})},get getBackwardEdges(){return __get__(this,function(self,sink){return function(){var __accu0__=[];for(var i=0;i<len(self.graph);i++)if(self.graph[i][sink]!=
self._no_edge&&i!=sink)__accu0__.append(i);return __accu0__}()})},get getEmptyPathList(){return __get__(this,function(self){var paths=[];for(var _=0;_<len(self.graph);_++)paths.append([]);return paths})},get buildCompactFwdGraph(){return __get__(this,function(self){self.compactFwdGraph=self.getEmptyPathList();for(var node=0;node<len(self.graph);node++)self.compactFwdGraph[node]=self.getForwardEdges(node)})},get buildCompactBkdGraph(){return __get__(this,function(self){self.compactBkdGraph=self.getEmptyPathList();
for(var node=0;node<len(self.graph);node++)self.compactBkdGraph[node]=self.getBackwardEdges(node)})},get getAllPredecessors(){return __get__(this,function(self,node,memoize){if(typeof memoize=="undefined"||memoize!=null&&memoize.hasOwnProperty("__kwargtrans__"))var memoize=false;if(!self.compactBkdGraph)self.buildCompactBkdGraph();var memoize=memoize||node==self.newEdgeSource;if(memoize)var pathDict=dict();var visited=set();var visitedList=[];var currentNode=node;var stack=[currentNode];var path=
[];while(len(stack)>0){var currentNode=stack.py_pop();if(currentNode==self._invalid_node)var path=path.__getslice__(1,null,1);else if(!__in__(currentNode,visited)){visited.add(currentNode);visitedList.append(currentNode);var path=[currentNode]+path;if(memoize)pathDict[currentNode]=self.deepcopyList(path);stack.append(self._invalid_node);var stack=self.extend(stack,self.compactBkdGraph[currentNode])}}if(self._debug)print("getAllPredecessors: node: {} and visitedList: {}".format(node,visitedList));
if(node==self.newEdgeSource)self.pathsToNewEdgeSource=pathDict;if(memoize)self.pathsToNode[node]=pathDict;return visitedList})},get getAllPredecessorsUnordered(){return __get__(this,function(self,node,memoize){if(typeof memoize=="undefined"||memoize!=null&&memoize.hasOwnProperty("__kwargtrans__"))var memoize=true;var memoize=memoize||node==self.newEdgeSource;if(memoize)var pathDict=dict();var visited=set();var currentNode=node;var stack=[currentNode];var path=[];while(len(stack)>0){var currentNode=
stack.py_pop();if(currentNode==self._invalid_node)var path=path.__getslice__(1,null,1);else if(!__in__(currentNode,visited)){visited.add(currentNode);var path=[currentNode]+path;if(memoize)pathDict[currentNode]=self.deepcopyList(path);stack.append(self._invalid_node);var stack=self.extend(stack,self.compactBkdGraph[currentNode])}}if(self._debug)print("getAllPredecessors: node: {} and visitedList: {}".format(node,visited));if(node==self.newEdgeSource)self.pathsToNewEdgeSource=pathDict;if(memoize)self.pathsToNode[node]=
pathDict;return visited})},get getAllSuccessors(){return __get__(this,function(self,node){if(!self.compactFwdGraph)self.buildCompactFwdGraph();var visited=set();var visitedList=[];var currentNode=node;var stack=[node];var path=[];while(len(stack)>0){var currentNode=stack.py_pop();if(currentNode==self._invalid_node)path.py_pop();else if(!__in__(currentNode,visited)){visited.add(currentNode);visitedList.append(currentNode);path.append(currentNode);if(node==self.newEdgeSink)self.pathsFromNewEdgeSink[currentNode]=
self.deepcopyList(path);stack.append(self._invalid_node);var stack=self.extend(stack,self.compactFwdGraph[currentNode])}}if(self._debug)print("getAllSuccessors: node = {} and visited list: {}".format(node,visitedList));return visitedList})},get deepcopyList(){return __get__(this,function(self,path){var copy=[];for(var entry of path)copy.append(entry);return copy})},get findPath(){return __get__(this,function(self,source,sink){var path=[];var visited=set();var stack=[source];while(len(stack)>0){var currentNode=
stack.py_pop();if(currentNode==self._invalid_node)path.py_pop();else if(!__in__(currentNode,visited)){var path=path+[currentNode];if(currentNode==sink)return tuple([true,path]);visited.add(currentNode);stack.append(self._invalid_node);var stack=self.extend(stack,self.compactFwdGraph[currentNode])}}return tuple([false,[]])})},get findPair(){return __get__(this,function(self,source,sink){if(!bool(self.pathsFromNewEdgeSink))self.getAllSuccessors(self.newEdgeSink);if(!bool(self.pathsToNewEdgeSource))self.getAllPredecessors(self.newEdgeSource);
var firstSegment=self.pathsToNewEdgeSource[source];var lastSegment=self.pathsFromNewEdgeSink[sink];var __left0__=self.findPath(source,sink);var _=__left0__[0];var secondPath=__left0__[1];if(source==sink)var secondPath=self.identityFunction(source);return tuple([firstSegment+lastSegment,secondPath])})},get __init__(){return __get__(this,function(self){self.graph=[[]];self.identityFunction=function __lambda__(source){return[source]};self.newEdgeSource=self._invalid_node;self.newEdgeSink=self._invalid_node;
self.timeTaken=0;self.compactFwdGraph=[];self.compactBkdGraph=[];self.pathsToNewEdgeSource=dict();self.pathsFromNewEdgeSink=dict();self.pathsToNode=dict();self._no_edge=_default_no_edge;self.noIdentity=false;self._invalid_node=-1})},get setGraph(){return __get__(this,function(self,graph,noEdge){if(typeof noEdge=="undefined"||noEdge!=null&&noEdge.hasOwnProperty("__kwargtrans__"))var noEdge=_default_no_edge;self.graph=graph;self._no_edge=noEdge;self.buildCompactBkdGraph();self.buildCompactFwdGraph()})},
get setEdge(){return __get__(this,function(self,source,sink){self.newEdgeSource=source;self.newEdgeSink=sink})},get getPathsToCheck(){return __get__(this,function(self){})},get getComputeTime(){return __get__(this,function(self){return self.timeTaken})},get setIdFunction(){return __get__(this,function(self,idFunction){self.identityFunction=idFunction})}});export var OptimalSetPathChecker=__class__("OptimalSetPathChecker",[BaseOnlineChecker],{__module__:__name__,get __init__(){return __get__(this,
function(self){__super__(OptimalSetPathChecker,"__init__")(self)})},get getSuccessors(){return __get__(this,function(self,source,sink){var predecessors=self.getAllPredecessors(source);var successors=self.getAllSuccessors(sink);if(self.noIdentity&&source==sink)return function(){var __accu0__=[];for(var src of predecessors)for(var snk of successors)if(src==snk)__accu0__.append(tuple([src,snk]));return set(__accu0__)}();return function(){var __accu0__=[];for(var src of predecessors)for(var snk of successors)__accu0__.append(tuple([src,
snk]));return set(__accu0__)}()})},get getRootPairs(){return __get__(this,function(self){var acceptedPairs=set();var predecessors=self.getAllPredecessors(self.newEdgeSource);var successors=self.getAllSuccessors(self.newEdgeSink);var potentialPairs=function(){var __accu0__=[];for(var source of predecessors)for(var sink of successors)__accu0__.append(tuple([source,sink]));return set(__accu0__)}();var orderedPotentialPairs=function(){var __accu0__=[];for(var source of predecessors)for(var sink of successors)__accu0__.append(tuple([source,
sink]));return __accu0__}();while(len(potentialPairs)!=0){var __left0__=orderedPotentialPairs.py_pop(0);var source=__left0__[0];var sink=__left0__[1];if(__in__(tuple([source,sink]),potentialPairs)){potentialPairs.remove(tuple([source,sink]));var __left0__=self.findPath(source,sink);var pathExists=__left0__[0];var _=__left0__[1];if(pathExists){var currentPairSuccessors=self.getSuccessors(source,sink);for(var redundantPair of acceptedPairs.intersection(currentPairSuccessors))acceptedPairs.remove(redundantPair);
for(var redundantPair of potentialPairs.intersection(currentPairSuccessors))potentialPairs.remove(redundantPair);acceptedPairs.add(tuple([source,sink]))}}}return acceptedPairs})},get getPathsToCheck(){return __get__(this,function(self){var startTime=time.time();var subset=self.getRootPairs();var pathPairs=[];for(var node of subset){var __left0__=node;var source=__left0__[0];var sink=__left0__[1];pathPairs.append(self.findPair(source,sink))}var endTime=time.time();self.timeTaken=endTime-startTime;
return pathPairs})}});export var _EMPTY=0;export var checker=OptimalSetPathChecker();export var oracle=function __lambda__(matrix1,matrix2){return matrix1==matrix2};export var getTime=function(){document.getElementById("time").innerHTML=checker.getComputeTime()};export var getPathsToCheck=function(){if(len(checker.graph)!=_EMPTY&&len(checker.graph[0])!=_EMPTY&&checker.newEdgeSource!=checker._invalid_node&&checker.newEdgeSink!=checker._invalid_node)document.getElementById("paths").innerHTML=checker.getPathsToCheck();
else document.getElementById("paths").innerHTML="Graph or new edge not yet set."};export var setGraph=function(){var graphString=document.getElementById("graph").value;var rows=graphString.py_split(";");var graph=[];for(var rowString of rows){var row=[];var splitRow=rowString.py_split();for(var edge of splitRow)row.append(int(edge));graph.append(row)}checker.setGraph(graph)};export var setNewEdge=function(){var edgeString=document.getElementById("edge").value;var __left0__=edgeString.py_split();var source=
__left0__[0];var sink=__left0__[1];checker.setEdge(int(source),int(sink))};export var scalarMultiply=function(scalar,matrix){var ans=[];for(var row of matrix){var ansRow=[];for(var elem of row)ansRow.append(scalar*elem);ans.append(ansRow)}return ans};export var metrixMultiple=function(mat1,mat2){if(isinstance(mat1,list))if(isinstance(mat2,list)){var ans=[];for(var row of len(mat1)){var ansRow=[];var vector1=mat1[row];for(var col of len(mat2[0])){var vector2=function(){var __accu0__=[];for(var i=0;i<
len(mat2);i++)__accu0__.append(mat2[i][row]);return __accu0__}();var sumOfEntries=0;for(var i=0;i<len(vector2);i++)sumOfEntries+=vector1[i]*vector2[i];ansRow.append(sumOfEntries)}ans.append(ansRow)}return ans}else return scalarMultiply(__kwargtrans__({scalar:mat2,matrix:mat1}));else if(isinstance(mat2,list))return scalarMultiply(__kwargtrans__({scalar:mat1,matrix:mat2}));else return mat1*mat2};export var getMatrixOfPaths=function(path,graphValues){var productMatrix=1;if(len(path)<2)return productMatrix;
for(var i=1;i<len(path);i++){var edgeMatrix=graphValues();matrixMultiply(productMatrix,edgeMatrix)}};export var checkPaths=function(pathsToCheck,graphValues,oracle){for(var pathPair of pathsToCheck){var __left0__=pathPair;var path1=__left0__[0];var path2=__left0__[1];var matrix1=getMatrixOfPaths(path1,graphValues);var matrix2=getMatrixOfPaths(path2,graphValues);if(!oracle(matrix1,matrix2))return false}return true};export var verify=function(graph,graphValues,newEdge,oracle){checker.setGraph(graph);
checker.setEdge(newEdge[0],newEdge[1]);var pathsToCheck=checker.getPathsToCheck();return checkPaths(pathsToCheck,graphValues,newEdge,oracle)};

//# sourceMappingURL=hello.map