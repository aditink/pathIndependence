\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{soul}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage[options ]{algorithm2e}
\usepackage{listings}
\usepackage{xparse}
\usepackage{xcolor}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}


\title{Online verification of commutativity}

\author{ }
\date{March 2020}

\begin{document}

\maketitle

\section{Introduction}
Consider the graph representing a category where every path between a common source and sink is equal. 
% Morphisms semantically represent natural transformations between objects.
Such \textit{path independent graphs} arise frequently in practice- from the implicit type conversion graph for a program in a language like scala, to the category of units of measure where morphisms are conversions between the units. 
Fundamentally, graphs representing systems with sets and "natural" transformations between the sets have this property by construction.
It is often useful to be able to verify that a category is indeed stays path independent over the course of construction. We present an efficient way to perform such a check, and evaluate our idea through two case studies. 

First, in the domain specific geometry type language \textit{Gator}, our algorithm is used to ensure that user defined transformations between spaces stay consistent, and the compiler, deterministic as it makes automatic conversion choices. As a second case study, the the algorithm is used to identify inefficiencies in a currency conversion graph.

\section{Algorithm}
The objective of the algorithm, given a path independent graph and a new edge to add, is to return that either the new graph after the addition of the edge is path independent, or that addition of the edge results in a loss of path independence along with an example pair of paths that have a common source and sink (\textit{comparable paths}).
It assumes the existence of a path equality checking oracle. 

For simplicity we will also assume that the graph has an implicit identity morphism on every node. However, with a few modifications, this algorithm can be extended to graphs without the identity.

\subsection{Comparable Path pair finding}

A graph is path independent if there exists no pair of comparable paths that are not equal.

Thus we begin by identifying all possible common sources and sinks that have a pair of paths, noting that equality of all pairs of paths such that one path does not include the new edge and the other does, along with the assumption that the existing graph is path independent, implies that all pairs comparable paths between the source and sink in the new, augmented graph are equal. 

\begin{lemma}
Equality of all pairs of paths such that one path does not include the new edge and the other does, and of cycles that include the new edge exactly once, along with the assumption that the existing graph is path independent, implies that the new, augmented graph is path independent.
\end{lemma}
\begin{proof}
A graph is path independent if there exists no comparable pair of paths that is not equal.

For a comparable pair where neither path contains the new edge, the pair was also present in the old, path independent graph. Since it was path independent, the two paths must be equal.

Upon verification that all cycles are equal to the identity, the path containing the new edge more than once is known to be equal to a path with the same start and end nodes that 

For a comparable pair where both paths contain 
\end{proof}

\begin{verbatim}
Graph existingGraph;
Edge newEdge;

Set comparablePaths = new Set();
for S in existingGraph.Nodes():
    for T in existingGraph.Nodes():
        try:
            Path pathWithNewEdge = 
                FindPath(
                    graph: existingGraph, 
                    sourceNode: S,
                    sinkNode: newEdge.Source()) +
                newEdge as Path +
                FindPath(
                    graph: existingGraph, 
                    sourceNode: newEdge.Sink(), 
                    sinkNode: T)
            if (S==T):
                // Cycles are a speacial case.
                pathInOldGraph = pathWithNewEdge + pathWithNewEdge
            else:
                Path pathInOldGraph = FindPath(
                    graph: existingGraph, 
                    sourceNode: S, 
                    sinkNode: T);
            comparablePaths.add((pathInOldGraph, pathWithNewEdge));
        catch (pathFindingFailed Exception):
            print(
                $"No comparable pairs from node {S} to node {T} that need to be checked");

output comparablePaths;
\end{verbatim}

The try block is executed at most n(n-1)/2 = $O(n^2)$ times where n is the number of nodes.

This bound is asymptotically tight.
This can be seen in the case where the graph contains 2N nodes besides S and T. We consider N of the nodes to be in group 1, and the other N to be in group 2. Every node in group 1 has a forward node to every node in group 2, as well as to S. T has a forward edge to every node in group 2. In this graph, on the addition of edge (S, T), $N^2$ paths need to be verified which is polynomial in 2N+2.

Also notice that if trying to optimize for path length (say, if composing functions is expensive) then "find any path" can be replaced with "find shortest path".


\subsection{(Optional) Optimization Step}

In the case where equality checks are very expensive, we begin by finding the minimal set of (source, sink) pairs such that checking for these pairs logically implies having checked the full graph.

However, we observe that there are some redundancies.

Consider the following situation:

\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (16.6,-34.1) circle (3);
\draw (16.6,-34.1) node {$S$};
\draw [black] (56.8,-33.6) circle (3);
\draw (56.8,-33.6) node {$T$};
\draw [black] (28,-20.1) circle (3);
\draw (28,-20.1) node {$P_1$};
\draw [black] (44.5,-20.1) circle (3);
\draw (44.5,-20.1) node {$P_2$};
\draw [black] (28,-44.9) circle (3);
\draw (28,-44.9) node {$Q_1$};
\draw [black] (44.5,-44.9) circle (3);
\draw (44.5,-44.9) node {$Q_2$};
\draw [black] (31,-20.1) -- (41.5,-20.1);
\fill [black] (41.5,-20.1) -- (40.7,-19.6) -- (40.7,-20.6);
\draw (36.25,-20.6) node [below] {$g_1$};
\draw [black] (26.11,-22.43) -- (18.49,-31.77);
\fill [black] (18.49,-31.77) -- (19.39,-31.47) -- (18.61,-30.84);
\draw (21.74,-25.67) node [left] {$f_1$};
\draw [black] (25.82,-42.84) -- (18.78,-36.16);
\fill [black] (18.78,-36.16) -- (19.01,-37.08) -- (19.7,-36.35);
\draw (23.57,-39.02) node [above] {$f_2$};
\draw [black] (31,-44.9) -- (41.5,-44.9);
\fill [black] (41.5,-44.9) -- (40.7,-44.4) -- (40.7,-45.4);
\draw (36.25,-45.4) node [below] {$g_2$};
\draw [black] (54.59,-35.63) -- (46.71,-42.87);
\fill [black] (46.71,-42.87) -- (47.64,-42.7) -- (46.96,-41.96);
\draw (49.21,-38.76) node [above] {$h_2$};
\draw [black] (54.78,-31.38) -- (46.52,-22.32);
\fill [black] (46.52,-22.32) -- (46.69,-23.25) -- (47.43,-22.57);
\draw (51.19,-25.39) node [right] {$h_1$};
\draw [black] (28,-23.1) -- (28,-41.9);
\fill [black] (28,-41.9) -- (28.5,-41.1) -- (27.5,-41.1);
\draw (27.5,-32.5) node [left] {$l$};
\draw [black] (19.6,-34.06) -- (53.8,-33.64);
\fill [black] (53.8,-33.64) -- (52.99,-33.15) -- (53.01,-34.15);
\draw [black] (44.5,-41.9) -- (44.5,-23.1);
\fill [black] (44.5,-23.1) -- (44,-23.9) -- (45,-23.9);
\draw (45,-32.5) node [right] {$m$};
\end{tikzpicture}
Each arrow represents a path, and (S,T) is the new edge being added.
\end{center}
TODO backward compositions.
\paragraph{Theorem} 
If conflicting paths $g_2 = f_2 \circ (S,T) \circ h_2$ then it must be that $g_1 = f_1 \circ (S,T) \circ h_1$.

% monomorphisms

\paragraph{Proof}
We use the fact that $f_1$=$l\circ f_2$ and $h_1$=$h_2 \circ m$.
\[g_2 = f_2 \circ (S,T) \circ h_2 \Rightarrow l \circ g_2 = l \circ f_2 \circ (S,T) \circ h_2 \Rightarrow l \circ g_2 \circ m = l \circ f_2 \circ (S,T) \circ h_2 \circ m \Rightarrow g_1 = f_1 \circ (S,T) \circ h_1\]

Note that the proof is not affected if an of these paths is the identity, eg. if $f_1$ is the identity and S and $P_1$ are actually the same node.

We conclude that verifying a comparable pair of paths with end points ($P_1$, $P_2$) implies the verification of all path pairs ($Q_1$, $Q_2$) such that $Q_1$ is a successor of $P_1$ and $P_2$ is a successor of $Q_2$. A successor S to node N is any node such that there exists a path from N to S. Nodes are also their own successors and predecessors.

Under the assumption that the only path operations allowed are composition and replacement of one path by a different, equal path, this reduction rule is also the only reduction rule.
That is to say, if verifying a comparable pair of paths with end points ($P_1$, $P_2$) implies the verification of a pair with endpoints ($Q_1$, $Q_2$), then it must be that $Q_1$ is a successor of $P_1$ and $P_2$ is a successor of $Q_2$.

TODO add proof. Maybe reference lemma below *after* introducing path semantics.

Using this information it is possible to choose a minimal subset of path pairs to verify, using a set-cover oracle.

We construct a graph with a node for each possible (source, sink) pair in the graph- each node then represents a possible choice for comparable path pair endpoints. Then we assign sets for every choice of inclusion of a (source, sink) comparable pair- the members of a set corresponding to a pair P consists of those nodes corresponding to those pairs whose verification would be implied by the verification of P.
All nodes that do not have conflicting pairs such that one path includes the new edge and the other doesn't are removed (i.e. all pairs corresponding to iterations of the comparable path finding algorithm where the catch block was entered).

Set cover gives us the smallest selection of sets that would allow for verification of every necessary node pair in the graph.

\begin{verbatim}
# Existng graph
Graph existingGraph;
# New edge
Edge (S, T);

predecessors = S.predecessors(existingGraph)
successors = T.successors(existingGraph)

# Construct the graph
Graph terminalPairGraph;
for q in successors:
    for p in predecessors:
        terminalPairGraph.addNode(q, p)
        # addEdge function should handle addition of edges between nodes that 
        # haven't been defined yet
        for q_pred in q.predecessors(existingGraph):
            for p_succ in p.successors(existingGraph):
                terminalPairGraph.addEdge((q_pred, p_succ))

# Now we reduce the graph.
verificationSet = {}
while (len(terminalPairGraph.nodes) > 0):
    # Choose a random node to start reduction from.
    current_node = terminalPairGraph.nodes[0]
    visited_nodes = set()
    # Climb up the graph till a "root" node is found
    while (len(currentNode.parents()) > 0):
        visited_nodes.add(currentNode)
        # Choose a parent at random.
        currentNode = currentNode.parents()[0]
        # Deal with cycles by reducing them
        if currentNode in visited_nodes:
            edges = getAllEdges(visited_nodes, terminalPairGraph)
            terminalPairGraph.removeNodes(visitedNodes)
            # All the incoming and outgoing edges from the entire visited set are now 
            # transferred to a single node that represents the class
            terminalPairGraph.addNode(currentNode, edges)
    # No predecessor! We should have reached a root!
    verificationSet.add(currentNode)
    terminalPairGraph.removeNodes(currentNode.successors(terminalPairGraph)

# This contains the minimal set of (source, sink) pairs whose verification 
# implies verification of the entire graph. 
return verificationSet
    
\end{verbatim}

% Here is a naive implemenetation. Note that an important optimization in sparse graphs can be made: Source-sink pairs with no viable adjacent pair should never be added to the graph (as verified by the try-catch block from the first algorithm).

\subsection{Verification}
Ultimately verification is performed simply by calling an equality oracle for every comparable pair returned by the previous stage.

\begin{verbatim}
for (path_1, path_2) in comparablePaths:
    if (path_1 != path_2):
        print($"Edge addition does not maintain path independence. 
        Counterexample: {path_1}, {path_2}")
        return False
print("Edge addition maintains path independence.")
return True
\end{verbatim}

\section{Proofs of Correctness}
This section might be easier if I write up a reduction semantics for paths, which I need for the proof of minimality anyway. Not sure where the best place to introduce these semantics would be- maybe here? TODO.

\subsection{Verifying every path returned by the Comparable Path Pair finding algorithm implies that the new graph is path independent}
*TODO fill out*

- No point in doing a pair unless exactly one has new edge / it's a cycle

- Excepting the cases already dismissed, there is no conflicting pair such that its information is not covered by one of the paths in the final set.

\subsection{Verifying every path returned by the Optimization algorithm implies that the new graph is path independent}
Structure optimization section into lemmas and reference those and the previous paragraph.

\section{Run time and efficiency analysis}

\subsection{Comparable path finding}
TODO fill in

- Polynomial
- Asymptotically optimal number of paths in worst case, since if addition of a path is a single step then at least $n^2$ steps required in worst case so O($n^2$) is a theoretical lower bound on run time.
- Maybe path finding subroutine can be more efficient

\subsection{Minimization problem}
This problem is NP hard.

TODO Show reduction from set cover.

Therefore we can't do much better than reducing to another NP complete problem. 

\section{Case Studies}

\subsection{Gator}
\subsection{Currencies}

\end{document}


// Finish write up
// Ordering
// Currency
// Semantics